import{s as on,n as Le}from"./CrGyUMwP.js";import{S as rn,i as cn,d as a,a as t,k as c,c as l,l as p,g as s,m as G,h as o,j as i,H as K}from"./uW2q-9yC.js";function hn(nn){let r,Me='<ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#what-is-flix">What is Flix?</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#background">background</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#the-why">the why</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#effects-in-flix">Effects in Flix</a></li></ol></li></ol></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#setup">Setup</a></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#resources">Resources</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#papers">Papers</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#talks">Talks</a></li></ol></li></ol>',Q,h,_e='<a aria-hidden="true" tabindex="-1" href="#what-is-flix"><span class="icon icon-link"></span></a>What is Flix?',X,f,Ce='<a aria-hidden="true" tabindex="-1" href="#background"><span class="icon icon-link"></span></a>background',$,x,Ie=`<a href="https://flix.dev/" rel="nofollow">Flix</a> is a JVM language. I want to preface any fancy category theory talk and PL research focused features could scare people away.
Flix can import and run Java packages, giving it a boost over many similar research languages in my opinion. The standard library doesn’t have something?
Ok use a Java library. Flix feels somewhat production ready, it comes with a good LSP, fast compiler, and built in Test support. This is an oversimplification,
but there is a good deal of truth behind it. A research language that doesn’t have do do everything at once to be useful is great for getting off the ground running.`,ee,g,Ee="Flix’s compiler is written in Scala using the <code>asm</code> bytecode library, and delivers performant <code>jar</code> executables. I am biased as I worked as a researcher alongside Professor Magnus Madsen’s Lab, where Flix was created. The lab there has really talented researchers, and almost more importantly for a large software project, extremely apt programmers. There is usually a divide between the quality of one’s research and their software engineering chops, but this is not the case with Magnus’s lab.",ne,d,Be='<a aria-hidden="true" tabindex="-1" href="#the-why"><span class="icon icon-link"></span></a>the why',ae,b,Pe="Why do we need a new language? There are already so many, and most are barely used or useful. Well, programming is changing and I think it’s most likely a good thing.The essence of computation is abstraction, and new abstractions are always being proposed some of which are pretty groundbreaking. Flix incorporates one such innovation, <strong>Algebraic Effects</strong>.",te,k,Ze="Before going into Effects I think it’s helpful to think of a previous great abstraction, the <strong>Monad</strong>. Monads allow for the sequencing of computations that might have effects (and are monoids in the category of endofunctors of course). They’re great but they are not the easiest things to use, especially when composing them. If you have ever seen a video of ice divers, people who dive and swim under ice, sometimes they have trouble finding the hole prepared to leave the ice. That is somewhat what it feels like to program with monads. Once a value is in a monad it hard to get it out. The high bar of functional theory needed for effective monad use makes them useful but somewhat exclusionary.",se,T,je="Effects give similar benefits to monads (and many effect libraries are written with monads), being the encapsulation of computations and possible side Effects, but feel much easier to use from the perspective of a software engineer. An Effect invokes the idea of throwing errors and there are parallels but Algebraic Effects can express much more than throwing errors. To best understand Effect systems there are two main concepts that must be understood. The <strong>Effect</strong>, and the <strong>Handler</strong>.",ie,H,Fe=`Think of the Effect as an invoice or an I owe you. In essence you are telling the program what a function returns, without giving the logic of the function.
Conversely think of a Handler as the fulfillment of that invoice / IOU. It is the implementation that returns the type requested by the Effect. When a function has Effects, the Effects are included in the type signature of the function. If a function handles an Effect it is no longer in the type signature of the function, as the <em>Effect is Handled</em>.`,le,L,De="This psuedo code is an oversimplification but helps to illustrate this point.",pe,A,an=`<pre class="shiki gruvbox" style="background-color:#292828;color:#d4be98" tabindex="0"><code><span class="line"><span>effect Say &#123;</span></span>
<span class="line"><span>    hello(): String</span></span>
<span class="line"><span>    bye(): String</span></span>
<span class="line"><span>&#125;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def greet(): &#x3C;effect Say> &#123; // greet has Say effect</span></span>
<span class="line"><span>    if (meeting) &#123;</span></span>
<span class="line"><span>        Say.hello()</span></span>
<span class="line"><span>    &#125; else &#123;</span></span>
<span class="line"><span>        Say.bye()</span></span>
<span class="line"><span>    &#125;</span></span>
<span class="line"><span>&#125;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def main &#123; // main has no effects because they are handled</span></span>
<span class="line"><span>    run &#123;</span></span>
<span class="line"><span>        greet()</span></span>
<span class="line"><span>    &#125; with &#123; // handle effects</span></span>
<span class="line"><span>        hello() &#123;return "hello"&#125;</span></span>
<span class="line"><span>        bye() &#123;return "bye"&#125;</span></span>
<span class="line"><span>    &#125;</span></span>
<span class="line"><span>&#125;</span></span></code></pre>`,W,M,Se=`Ok, this looks like a roundabout way to program, why not just define <code>hello()</code> and <code>bye()</code>? Well what if we aren’t just using English? We can define handlers for
any greetings in any language. This makes our code more flexible, but isn’t anything that interfaces in OOP or Trait’s in FP couldn’t accomplish so what gives? Effects allow for more modularity without as much boilerplate. Additionally, with more complicated Effects we have continuations, meaning we can go back into the function at the stack frame in which the Effect was invoked.`,oe,u,Oe='<a aria-hidden="true" tabindex="-1" href="#effects-in-flix"><span class="icon icon-link"></span></a>Effects in Flix',re,_,Ae=`Flix has some of the best language support for Effects. This is mainly opinion but given the JVM preface I don’t think there is much of a debate.
Effect oriented languages have been springing up and although great they feel more “researchy” in the sense that it feels impossible to write large
projects with them. Flix feels like a general purpose language with Effects. You could write Flix without ever writing an Effect. The only interface with
Effects you would have are in the type signatures of Functions.`,ce,C,We="For example let’s look at the default <code>main</code> function when you init a project.",he,q,tn=`<pre class="shiki gruvbox" style="background-color:#292828;color:#d4be98" tabindex="0"><code><span class="line"><span>def main(): Unit  IO =</span></span>
<span class="line"><span>    println("Hello World!")</span></span></code></pre>`,U,I,qe="Here <code>Unit \\ IO</code> denotes a function that returns nothing (ie Unit) with the IO Effect. Being a builtin function <code>println</code> doesn’t Require handling <code>IO</code>. But handlers in Flix have some of the most developer friendly syntax (in my opinion). You denote effectful code with <code>run</code> and handle them with <code>with</code>.",fe,V,sn=`<pre class="shiki gruvbox" style="background-color:#292828;color:#d4be98" tabindex="0"><code><span class="line"><span>eff DivByZero &#123; // declaring 'DivByZero' effect</span></span>
<span class="line"><span>    def divByZero(): Void</span></span>
<span class="line"><span>&#125;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def divide(x: Int32, y: Int32): Int32  DivByZero = // 'divide' has effect 'DivByZero'</span></span>
<span class="line"><span>    if (y == 0) &#123;</span></span>
<span class="line"><span>        DivByZero.divByZero()</span></span>
<span class="line"><span>    &#125; else &#123;</span></span>
<span class="line"><span>        x / y</span></span>
<span class="line"><span>    &#125;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def main(): Unit  IO = // 'main' doesn't have 'DivByZero' effect as it is handled within the function</span></span>
<span class="line"><span>    run &#123;</span></span>
<span class="line"><span>        println(divide(3, 2));</span></span>
<span class="line"><span>        println(divide(3, 0))</span></span>
<span class="line"><span>    &#125; with handler DivByZero &#123;</span></span>
<span class="line"><span>        // every handled effect has an extra parameter, a continuation, for when you want to resume post handling</span></span>
<span class="line"><span>        def divByZero(_resume) = println("Oops: Division by Zero!")</span></span>
<span class="line"><span>    &#125;</span></span></code></pre>`,z,E,Ue=`We can see how Effects allow more modular code as changing <code>divByZero</code> or providing different implementation doesn’t change where it is called.
To show a basic usage of continuations we can refactor the <code>divByZero</code> Effect to return a default value using a <strong>continuation</strong>`,de,J,ln=`<pre class="shiki gruvbox" style="background-color:#292828;color:#d4be98" tabindex="0"><code><span class="line"><span>eff DivByZero &#123;</span></span>
<span class="line"><span>    def divByZero(x: Int32, y: Int32): Int32</span></span>
<span class="line"><span>&#125;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def divide(x: Int32, y: Int32): Int32  DivByZero = </span></span>
<span class="line"><span>    DivByZero.divByZero(x, y)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def main(): Unit  IO = </span></span>
<span class="line"><span>    run &#123;</span></span>
<span class="line"><span>        println(divide(3, 2)); // outputs 1</span></span>
<span class="line"><span>        println(divide(3, 0))  // outputs "oops" 0</span></span>
<span class="line"><span>    &#125; with handler DivByZero &#123;</span></span>
<span class="line"><span>        // every handled effect has an extra parameter, a continuation, for when you want to resume post handling</span></span>
<span class="line"><span>        def divByZero(x, y, resume) = match y &#123;</span></span>
<span class="line"><span>            case 0 => println("oops"); resume(0)</span></span>
<span class="line"><span>            case i => resume(x/i)</span></span>
<span class="line"><span>        &#125;</span></span>
<span class="line"><span>    &#125;</span></span></code></pre>`,N,B,Ve=`Here we handle division in the Effect Handler. The <code>divide</code> function is redundant but serves to show how Effects show up in type signatures.
Unhandled Effects must show up in the return type, but once handled they no longer need to. This can be seen in a more complicated example that show
how to define a handler function, and a helper to apply the handler in the <code>main</code> function.`,ue,R,pn=`<pre class="shiki gruvbox" style="background-color:#292828;color:#d4be98" tabindex="0"><code><span class="line"><span>eff DivByZero &#123;</span></span>
<span class="line"><span>    def div(x: Int32, y: Int32): Int32</span></span>
<span class="line"><span>&#125;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// handle DivByZero in function &#96;f&#96;</span></span>
<span class="line"><span>def handle(f: a -> b  ef): a -> b  (ef - DivByZero) + IO = x -> // return type lacks 'DivByZero'</span></span>
<span class="line"><span>   run &#123;</span></span>
<span class="line"><span>       f(x)</span></span>
<span class="line"><span>   &#125; with handler DivByZero &#123; // define handler</span></span>
<span class="line"><span>        def div(a, b, resume) = match b &#123;</span></span>
<span class="line"><span>            case 0 => println("oops"); resume(0)</span></span>
<span class="line"><span>            case i => resume(a/i)</span></span>
<span class="line"><span>        &#125;</span></span>
<span class="line"><span>   &#125;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// helper to handle the effect in a &#96;main&#96; function</span></span>
<span class="line"><span>def runDivWithIO(f: Unit -> a  ef): a  (ef - DivByZero) +  &#123;IO&#125; = handle(f)()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def main(): Unit  IO = </span></span>
<span class="line"><span>    run &#123;</span></span>
<span class="line"><span>        println(DivByZero.div(3, 2));</span></span>
<span class="line"><span>        println(DivByZero.div(3, 0))</span></span>
<span class="line"><span>    &#125; with runDivWithIO</span></span></code></pre>`,Y,m,ze='<a aria-hidden="true" tabindex="-1" href="#setup"><span class="icon icon-link"></span></a>Setup',me,P,Je=`Flix relies on its LSP for semantic highlighting and has great VSCode support. The plugin can be installed via the plugin panel. Additionally there is a
good Neovim <a href="https://github.com/flix/nvim" rel="nofollow">plugin</a> to get up and running. Flix relies on the <strong>flix.jar</strong> which is essentially a jvm binary containing the compiler
and LSP. VSCode will download one into it’s Cache or it can be <a href="https://github.com/flix/flix/releases/latest" rel="nofollow">downloaded</a> locally for use on a per project basis.`,ve,Z,Ne=`When using the jar from the CLI simply prefix any commands with <code>java -jar flix.jar</code>. For instance if I’m using the jar at the root of my project, to initialize
the project I would call <code>java -jar flix.jar init</code>.`,ye,j,Re='The Flix <a href="https://doc.flix.dev/introduction.html" rel="nofollow">book</a> provides full setup instructions and great documentation / examples to get started with the language!',we,v,Ye='<a aria-hidden="true" tabindex="-1" href="#resources"><span class="icon icon-link"></span></a>Resources',xe,y,Ge='<a aria-hidden="true" tabindex="-1" href="#papers"><span class="icon icon-link"></span></a>Papers',ge,F,Ke="Some good papers on Effects…",be,D,Qe='<li><a href="https://www.sciencedirect.com/science/article/pii/S1571066115000705?via%3Dihub" rel="nofollow">An Introduction to Algebraic Effects and Handlers. Invited tutorial paper.</a></li> <li><a href="https://dl.acm.org/doi/10.1145/3408981" rel="nofollow">Effect handlers, evidently.</a></li>',ke,w,Xe='<a aria-hidden="true" tabindex="-1" href="#talks"><span class="icon icon-link"></span></a>Talks',Te,S,$e="Some good Flix talks…",He,O,en='<li><a href="https://www.youtube.com/watch?v=RNZeAmp1EaA" rel="nofollow">Principles of the Flix Programming Language</a></li> <li><a href="https://www.youtube.com/watch?v=2LSOqikNqxM" rel="nofollow">An Introduction to Functional Imperative Programming in Flix</a></li>';return{c(){r=o("nav"),r.innerHTML=Me,Q=i(),h=o("h1"),h.innerHTML=_e,X=i(),f=o("h2"),f.innerHTML=Ce,$=i(),x=o("p"),x.innerHTML=Ie,ee=i(),g=o("p"),g.innerHTML=Ee,ne=i(),d=o("h2"),d.innerHTML=Be,ae=i(),b=o("p"),b.innerHTML=Pe,te=i(),k=o("p"),k.innerHTML=Ze,se=i(),T=o("p"),T.innerHTML=je,ie=i(),H=o("p"),H.innerHTML=Fe,le=i(),L=o("p"),L.textContent=De,pe=i(),A=new K(!1),W=i(),M=o("p"),M.innerHTML=Se,oe=i(),u=o("h3"),u.innerHTML=Oe,re=i(),_=o("p"),_.textContent=Ae,ce=i(),C=o("p"),C.innerHTML=We,he=i(),q=new K(!1),U=i(),I=o("p"),I.innerHTML=qe,fe=i(),V=new K(!1),z=i(),E=o("p"),E.innerHTML=Ue,de=i(),J=new K(!1),N=i(),B=o("p"),B.innerHTML=Ve,ue=i(),R=new K(!1),Y=i(),m=o("h1"),m.innerHTML=ze,me=i(),P=o("p"),P.innerHTML=Je,ve=i(),Z=o("p"),Z.innerHTML=Ne,ye=i(),j=o("p"),j.innerHTML=Re,we=i(),v=o("h1"),v.innerHTML=Ye,xe=i(),y=o("h2"),y.innerHTML=Ge,ge=i(),F=o("p"),F.textContent=Ke,be=i(),D=o("ul"),D.innerHTML=Qe,ke=i(),w=o("h2"),w.innerHTML=Xe,Te=i(),S=o("p"),S.textContent=$e,He=i(),O=o("ul"),O.innerHTML=en,this.h()},l(e){r=l(e,"NAV",{class:!0,"data-svelte-h":!0}),p(r)!=="svelte-1p6ct1b"&&(r.innerHTML=Me),Q=s(e),h=l(e,"H1",{id:!0,"data-svelte-h":!0}),p(h)!=="svelte-nzauja"&&(h.innerHTML=_e),X=s(e),f=l(e,"H2",{id:!0,"data-svelte-h":!0}),p(f)!=="svelte-5bj5w8"&&(f.innerHTML=Ce),$=s(e),x=l(e,"P",{"data-svelte-h":!0}),p(x)!=="svelte-17lgha1"&&(x.innerHTML=Ie),ee=s(e),g=l(e,"P",{"data-svelte-h":!0}),p(g)!=="svelte-1rd3ymw"&&(g.innerHTML=Ee),ne=s(e),d=l(e,"H2",{id:!0,"data-svelte-h":!0}),p(d)!=="svelte-9cwemf"&&(d.innerHTML=Be),ae=s(e),b=l(e,"P",{"data-svelte-h":!0}),p(b)!=="svelte-1fln3ob"&&(b.innerHTML=Pe),te=s(e),k=l(e,"P",{"data-svelte-h":!0}),p(k)!=="svelte-1f7owu6"&&(k.innerHTML=Ze),se=s(e),T=l(e,"P",{"data-svelte-h":!0}),p(T)!=="svelte-cvdb3a"&&(T.innerHTML=je),ie=s(e),H=l(e,"P",{"data-svelte-h":!0}),p(H)!=="svelte-gmmk6u"&&(H.innerHTML=Fe),le=s(e),L=l(e,"P",{"data-svelte-h":!0}),p(L)!=="svelte-ttdk5k"&&(L.textContent=De),pe=s(e),A=G(e,!1),W=s(e),M=l(e,"P",{"data-svelte-h":!0}),p(M)!=="svelte-rc9spa"&&(M.innerHTML=Se),oe=s(e),u=l(e,"H3",{id:!0,"data-svelte-h":!0}),p(u)!=="svelte-1rgw99g"&&(u.innerHTML=Oe),re=s(e),_=l(e,"P",{"data-svelte-h":!0}),p(_)!=="svelte-1c1whe4"&&(_.textContent=Ae),ce=s(e),C=l(e,"P",{"data-svelte-h":!0}),p(C)!=="svelte-5jeqwx"&&(C.innerHTML=We),he=s(e),q=G(e,!1),U=s(e),I=l(e,"P",{"data-svelte-h":!0}),p(I)!=="svelte-y0v0vo"&&(I.innerHTML=qe),fe=s(e),V=G(e,!1),z=s(e),E=l(e,"P",{"data-svelte-h":!0}),p(E)!=="svelte-17tl2zs"&&(E.innerHTML=Ue),de=s(e),J=G(e,!1),N=s(e),B=l(e,"P",{"data-svelte-h":!0}),p(B)!=="svelte-18ge4f9"&&(B.innerHTML=Ve),ue=s(e),R=G(e,!1),Y=s(e),m=l(e,"H1",{id:!0,"data-svelte-h":!0}),p(m)!=="svelte-jq0h7h"&&(m.innerHTML=ze),me=s(e),P=l(e,"P",{"data-svelte-h":!0}),p(P)!=="svelte-1a3ky8z"&&(P.innerHTML=Je),ve=s(e),Z=l(e,"P",{"data-svelte-h":!0}),p(Z)!=="svelte-tnj9pa"&&(Z.innerHTML=Ne),ye=s(e),j=l(e,"P",{"data-svelte-h":!0}),p(j)!=="svelte-185e5ya"&&(j.innerHTML=Re),we=s(e),v=l(e,"H1",{id:!0,"data-svelte-h":!0}),p(v)!=="svelte-10dcxat"&&(v.innerHTML=Ye),xe=s(e),y=l(e,"H2",{id:!0,"data-svelte-h":!0}),p(y)!=="svelte-1t0a0n"&&(y.innerHTML=Ge),ge=s(e),F=l(e,"P",{"data-svelte-h":!0}),p(F)!=="svelte-135v9qx"&&(F.textContent=Ke),be=s(e),D=l(e,"UL",{"data-svelte-h":!0}),p(D)!=="svelte-atp0e6"&&(D.innerHTML=Qe),ke=s(e),w=l(e,"H2",{id:!0,"data-svelte-h":!0}),p(w)!=="svelte-xdvqs9"&&(w.innerHTML=Xe),Te=s(e),S=l(e,"P",{"data-svelte-h":!0}),p(S)!=="svelte-1xpwh97"&&(S.textContent=$e),He=s(e),O=l(e,"UL",{"data-svelte-h":!0}),p(O)!=="svelte-jcu7jl"&&(O.innerHTML=en),this.h()},h(){c(r,"class","toc"),c(h,"id","what-is-flix"),c(f,"id","background"),c(d,"id","the-why"),A.a=W,c(u,"id","effects-in-flix"),q.a=U,V.a=z,J.a=N,R.a=Y,c(m,"id","setup"),c(v,"id","resources"),c(y,"id","papers"),c(w,"id","talks")},m(e,n){t(e,r,n),t(e,Q,n),t(e,h,n),t(e,X,n),t(e,f,n),t(e,$,n),t(e,x,n),t(e,ee,n),t(e,g,n),t(e,ne,n),t(e,d,n),t(e,ae,n),t(e,b,n),t(e,te,n),t(e,k,n),t(e,se,n),t(e,T,n),t(e,ie,n),t(e,H,n),t(e,le,n),t(e,L,n),t(e,pe,n),A.m(an,e,n),t(e,W,n),t(e,M,n),t(e,oe,n),t(e,u,n),t(e,re,n),t(e,_,n),t(e,ce,n),t(e,C,n),t(e,he,n),q.m(tn,e,n),t(e,U,n),t(e,I,n),t(e,fe,n),V.m(sn,e,n),t(e,z,n),t(e,E,n),t(e,de,n),J.m(ln,e,n),t(e,N,n),t(e,B,n),t(e,ue,n),R.m(pn,e,n),t(e,Y,n),t(e,m,n),t(e,me,n),t(e,P,n),t(e,ve,n),t(e,Z,n),t(e,ye,n),t(e,j,n),t(e,we,n),t(e,v,n),t(e,xe,n),t(e,y,n),t(e,ge,n),t(e,F,n),t(e,be,n),t(e,D,n),t(e,ke,n),t(e,w,n),t(e,Te,n),t(e,S,n),t(e,He,n),t(e,O,n)},p:Le,i:Le,o:Le,d(e){e&&(a(r),a(Q),a(h),a(X),a(f),a($),a(x),a(ee),a(g),a(ne),a(d),a(ae),a(b),a(te),a(k),a(se),a(T),a(ie),a(H),a(le),a(L),a(pe),A.d(),a(W),a(M),a(oe),a(u),a(re),a(_),a(ce),a(C),a(he),q.d(),a(U),a(I),a(fe),V.d(),a(z),a(E),a(de),J.d(),a(N),a(B),a(ue),R.d(),a(Y),a(m),a(me),a(P),a(ve),a(Z),a(ye),a(j),a(we),a(v),a(xe),a(y),a(ge),a(F),a(be),a(D),a(ke),a(w),a(Te),a(S),a(He),a(O))}}}const fn={title:"Introduction to the Flix programming language",date:"07-14-25"},{title:mn,date:vn}=fn;class yn extends rn{constructor(r){super(),cn(this,r,null,hn,on,{})}}export{yn as default,fn as metadata};
